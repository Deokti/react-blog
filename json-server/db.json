{
  "users": [
    {
      "id": 1,
      "username": "admin",
      "password": "admin"
    },
    {
      "id": 2,
      "username": "deokmi",
      "password": "deokmi"
    }
  ],
  "articles": [
    {
      "id": "1",
      "title": "JavaScript. Ядро: 2-ое издание",
      "subtitle": "Данная статья является вторым изданием обзорной лекции JavaScript. Ядро, посвященной языку программирования ECMAScript, и ключевым компонентам его рантайм-системы.",
      "img": "https://yt3.ggpht.com/ytc/AAUvwnhKwOuCqaYgI52PIs1hz1JN_9Iz7NZfECu_FE-YMQ=s900-c-k-c0x00ffffff-no-rj",
      "originalArticle": "http://dmitrysoshnikov.com/ecmascript/javascript-the-core-2nd-edition-rus/",
      "createdBy": {
        "avatar": "http://2.gravatar.com/avatar/882f228c4993ccf0a86e96394636415c?s=100&d=mm&r=g",
        "name": "Dmitry Soshnikov"
      },
      "createdAt": "2017-12-05",
      "views": 1000,
      "types": ["IT", "JavaScript", "ECMAScript"],
      "blocks": [
        {
          "id": "1",
          "type": "TEXT",
          "paragraph": [
            "Первое издание статьи описывает аспекты JavaScript с точки зрения стандарта ES3 (на данный момент устаревшего), c небольшими отсылками к соответствующим изменениям в ES5 и ES6 (также известного как ES2015).",
            "Начиная с ES2015, в спецификации поменялись описания и структуры некоторых ключевых компонентов, были введены новые модели, термины и т.д. И в данном издании мы фокусируемся на новых абстракциях, обновленной терминологии, однако сохраняя базовую структуру JS, не изменяющуюся на протяжении всех версий стандарта.",
            "Данная статья описывает рантайм-систему ES2017+."
          ]
        },
        {
          "id": "2",
          "type": "NOTE",
          "text": "Обратите внимание: последнюю версию ECMAScript спецификации можно найти на сайте комитета TC-39."
        },
        {
          "id": "3",
          "type": "TEXT",
          "paragraph": [
            "Мы начинаем нашу дискуссию с рассмотрения концепции объекта, являющейся фундаментальной абстракцией в ECMAScript."
          ]
        },

        {
          "id": "4",
          "type": "TEXT",
          "paragraph": [
            "Рассмотрим простейшую схему объекта, с которой будем работать в последующих описаниях. На свой прототип объект ссылается посредством внутреннего свойства [[Prototype]], которое доступно в пользовательском коде через свойство __proto__.",
            "Для кода:"
          ]
        },
        {
          "id": "5",
          "type": "TEXT",
          "title": "Объект",
          "paragraph": [
            "ECMAScript — это объектно-ориентированный язык программирования с прототипной организацией, имеющий концепцию объекта в качестве базовой абстракции."
          ]
        },
        {
          "id": "6",
          "type": "DEFINITION",
          "text": "Определение 1: Объект — это коллекция свойств, имеющая также связанный с ней объект-прототип. Прототипом может быть также другой объект, или же значение null."
        },
        {
          "id": "7",
          "type": "CODE",
          "code": "let point = {\n  x: 10,\n  y: 20,\n};"
        },
        {
          "id": "8",
          "type": "TEXT",
          "paragraph": [
            "мы имеем следующую структуру с двумя явными собственными свойствами и одним неявным (внутренним) свойством __proto__, которое является ссылкой на прототип объекта point:"
          ]
        },
        {
          "id": "9",
          "type": "IMAGE",
          "src": "http://dmitrysoshnikov.com/wp-content/uploads/2017/11/js-object.png",
          "title": "Схема 1. Простейший объект с прототипом."
        },
        {
          "id": "10",
          "type": "NOTE",
          "text": "Обратите внимание: объекты также могут хранить символы."
        },
        {
          "id": "11",
          "type": "TEXT",
          "paragraph": [
            "Прототипные объекты используются для реализации наследования при помощи механизма динамической диспетчеризации (dynamic dispatch). Рассмотрим понятие цепи прототипов, чтобы увидеть этот механизм в действии."
          ]
        },
        {
          "id": "12",
          "type": "TEXT",
          "title": "Прототип",
          "paragraph": [
            "Каждый объект при создании получает свой прототип. Если прототип не задан явно, объекты получают базовый прототип по-умолчанию в качестве объекта наследнования."
          ]
        },
        {
          "id": "13",
          "type": "DEFINITION",
          "text": "Определение 2: Прототип — это объект-делегат, используемый для реализации прототипного наследования."
        },
        {
          "id": "14",
          "type": "TEXT",
          "paragraph": [
            "При создании объекта, его прототип может быть установлен явно через свойство __proto__, или же с помощью метода Object.create:"
          ]
        },
        {
          "id": "15",
          "type": "CODE",
          "code": "// Базовый объект.\nlet point = {\n  x: 10,\n  y: 20,\n};\n \n// Наследуем от объекта `point`.\nlet point3D = {\n  z: 30,\n  __proto__: point,\n};\n \nconsole.log(\n  point3D.x, // 10, унаследованное\n  point3D.y, // 20, унаследованное\n  point3D.z  // 30, собственное\n);"
        },
        {
          "id": "16",
          "type": "NOTE",
          "text": "Обратите внимание: по-умолчанию объекты получают Object.prototype в качестве наследуемого объекта."
        },
        {
          "id": "17",
          "type": "TEXT",
          "paragraph": [
            "Любой объект может быть использован в качестве прототипа другого объекта, и сам прототип может иметь свой собственный прототип. Если прототип имеет непустую ссылку на свой прототип, и т.д., такая связка называется цепью прототипов (prototype chain)."
          ]
        },
        {
          "id": "18",
          "type": "DEFINITION",
          "text": "Определение 3: Цепь прототипов — это конечная цепь объектов, используемая для реализации наследования и разделяемых свойств."
        },
        {
          "id": "19",
          "type": "IMAGE",
          "src": "http://dmitrysoshnikov.com/wp-content/uploads/2017/11/prototype-chain.png",
          "title": "Схема 2. Цепь прототипов."
        },
        {
          "id": "20",
          "type": "TEXT",
          "paragraph": [
            "Здесь правило очень простое: если свойство не найдено в самом объекте, осуществляется попытка разрешить (найти) это свойство в прототипе; в прототипе прототипа, и т.д. — до тех пор, пока вся цепь прототипов не будет рассмотрена.",
            "Данный механизм известен как динамическая диспетчеризация (dynamic dispatch) или делегация (delegation)."
          ]
        },
        {
          "id": "21",
          "type": "DEFINITION",
          "text": "Определение 4: Делегация — механизм, используемый для разрешения свойств в цепи наследования. Процесс осуществляется во время исполнения программы, поэтому также называется динамической диспетчеризацией."
        },
        {
          "id": "22",
          "type": "NOTE",
          "text": "Обратите внимание: в отличие от статической дипетчеризации, когда ссылки разрешаются во время компиляции, динамическая диспетчеризация всегда разрешает ссылки во время исполнения программы."
        },
        {
          "id": "23",
          "type": "TEXT",
          "paragraph": [
            "Eсли свойство в итоге не найдено во всей цепи прототипов, возвращается значение undefined:"
          ]
        },
        {
          "id": "24",
          "type": "CODE",
          "code": "// \"Пустой\" объект.\nlet empty = {};\n \nconsole.log(\n \n  // функция, из прототипа по-умолчанию\n  empty.toString,\n \n  // undefined\n  empty.x,\n \n);"
        },
        {
          "id": "25",
          "type": "TEXT",
          "paragraph": [
            "Как мы видим, обычный объект никогда не является пустым — он всегда наследует что-то из Object.prototype. Чтобы создать беспрототипный словарь, необходимо явно установить его прототип в null:"
          ]
        },
        {
          "id": "26",
          "type": "CODE",
          "code": "// Не наследуем ни от кого.\nlet dict = Object.create(null);\n \nconsole.log(dict.toString); // undefined"
        },
        {
          "id": "27",
          "type": "TEXT",
          "paragraph": [
            "Механизм динамической диспетчеризации также позволяет мутировать цепь наследования и менять объект-делегат:"
          ]
        },
        {
          "id": "28",
          "type": "CODE",
          "code": "let protoA = {x: 10};\nlet protoB = {x: 20};\n \n// То же, что и `let objectC = {__proto__: protoA};`:\nlet objectC = Object.create(protoA);\nconsole.log(objectC.x); // 10\n \n// Изменяем прототип:\nObject.setPrototypeOf(objectC, protoB);\nconsole.log(objectC.x); // 20"
        },
        {
          "id": "29",
          "type": "NOTE",
          "text": "Обратите внимание: несмотря на то, что свойство __proto__ на сегодняшний день стандартизовано, и проще для объяснения материала, на практике рекомендовано использование API методов для манипуляции с прототипами, таких как Object.create, Object.getPrototypeOf, Object.setPrototypeOf, и схожих в модуле Reflect."
        },
        {
          "id": "30",
          "type": "TEXT",
          "paragraph": [
            "На примере Object.prototype, мы видим, что один и тот же прототип может наследоваться многими объектами. На этом принципе простроено классовое наследование в ECMAScript. Давайте рассмотрим пример и заглянем в детали реализации абстракции “класс” в JS."
          ]
        }
      ]
    }
  ],
  "comments": [
    {
      "id": 1,
      "articleId": 1,
      "text": "Статья не полная. Если перейти на оригинальный сайт, на нём расскрываются больше тем. Дополните!",
      "userId": 1,
      "createdAt": "2017-12-06"
    },
    {
      "id": 2,
      "articleId": 1,
      "text": "Какой-то комментария, чтобы проверить его отображение на странице",
      "userId": 2,
      "createdAt": "2017-12-07"
    }
  ],
  "profile": [
    {
      "username": "KaizDA",
      "firstname": "Kain",
      "lastname": "Randolph",
      "age": 24,
      "currency": "RUB",
      "country": "Russia",
      "city": "Moscow",
      "avatar": "https://sun6-22.userapi.com/s/v1/if1/Pr3hfZHumqP2o7GDvHiUBtZmqjlh0plvSrlFfow41X8zoHPMn5Csr6agnOc70WmVdi3jbw.jpg?size=500x618&quality=96&crop=0,0,500,618&ava=1"
    }
  ]
}
